##############################
## Testing custom functions ##
##############################

##############
## Preamble ##
##############
## Add directory of function files to search path (not working due to invalid ELF header):
## addpath("functions/");
## Source function files:
source("functions/van_Genuchten_variables.oct");
source("functions/adjacent_mean.oct");
source("functions/exp_notation.oct");
## Set graphics toolkit:
graphics_toolkit("gnuplot");
## Set working directory:
cd("/home/renke/home_Projekt/Octave");
## Set destination directory for test data:
data_dir = "../Daten/Probelaeufe/";

######################
## (Re-)Create data ##
######################
## Load data:
load (cat(2, data_dir, "K_rand"));
load (cat(2, data_dir, "theta_rand"));
load (cat(2, data_dir, "C_rand"));
## Set model parameters:
nr_of_timesteps = 10;
nr_of_nodes = 10;
## Create vector with values for x-axis:
timesteps = 1:nr_of_timesteps;
## Create vector with values for y-axis:
nodes = 1:nr_of_nodes;

## Set function parameters (values taken from Celia et al. (1990), p. 1487 below eq. (13b)):
alpha = 0.0335;
theta_s =0.368;
theta_r = 0.102;
n = 2;
K_s = 0.00922;
h = randi([-1000, -500], 10,1);
## Calculate:
for timestep = 1:nr_of_timesteps
  [K(:, timestep), theta(:, timestep), C(:, timestep)] = van_Genuchten_variables(alpha = alpha,
								 n = n,
								 theta_r = theta_r,
								 theta_s = theta_s,
								 K_s = K_s,
								 h = h);
endfor
## Vary results for plotting:
for column = 1:columns(K)
  K_rand(:,column) = K(:, column) .* randi([1, 10], 1, 1);
endfor
for column = 1:columns(theta)
  theta_rand(:,column) = theta(:, column) .* randi([1, 10], 1, 1);
endfor
for column = 1:columns(C)
  C_rand(:,column) = C(:, column) .* randi([1, 10], 1, 1);
endfor
## Save data:
save_default_options("-text");
save (cat(2, data_dir, "K_rand.csv"), "K_rand");
save (cat(2, data_dir, "theta_rand.csv"), "theta_rand");
save (cat(2, data_dir, "C_rand.csv"), "C_rand");

##############################################
## Plot “K” against “timesteps” and “nodes” ##
##############################################

close all;
figurehandle = figure("papertype",
		  "a4",
		  "paperorientation",
		  "landscape",
		  "paperunits",
		  "centimeters",
		  "paperposition",
		  [2 2 17 25.6],
		  "visible",
		  "off");
		  ## "on");
xlabel("Timestep");
ylabel("Node");
zlabel("Hydraulic conductivity [cm/s]");
axis([0;
      nr_of_timesteps + 1;
      0;
      nr_of_nodes + 1;
      min(min(K_rand)) - 1 * (10 ^ -9);
      max(max(K_rand)) + 1 * (10 ^ -7)],
     "tic",
     "label");
grid ("on");
view(45,
     35);
color = ["k"];
linestyle = "-";
linewidth = 2;
markerstyles = ["o";
	      "o";
	      "s";
	      "s";
	      "d";
	      "d";
	      "^";
	      "^";
	      "v";
	      "v"];
markeredgecolor = ["k"];
markerfacecolor = ["auto";
	         "none"];
## Create plots using for-loop:
for row = 1:rows(K_rand)
  line(timesteps,
       nodes(row),
       ## K_rand(row,:).', ## transposing seems to result in plotting the same line mutlitple times
       K_rand(row,:),
       "linewidth",
       linewidth,
       "linestyle",
       linestyle,
       "color",
       color,
       "marker",
       markerstyles(row),
       "markeredgecolor",
       markeredgecolor,
       "markerfacecolor",
       markerfacecolor(1 .+ rem(row, 2)));
endfor
## Add legend:
legend("Node 01",
       "Node 02",
       "Node 03",
       "Node 04",
       "Node 05",
       "Node 06",
       "Node 07",
       "Node 08",
       "Node 09",
       "Node 10");
system("rm -vf ../Grafiken/K_rand_3D_plot.pdf");
print(figurehandle,
      "../Grafiken/K_rand_3D_plot.pdf");
system("mupdf -r 66 ../Grafiken/K_rand_3D_plot.pdf &");

################################
## Calculate mean values of K ##
################################

K_rand_mean = adjacent_mean(K_rand,"a");

rows(K_rand)
rows(K_rand_mean)

###########
## Model ##
###########

## Set model parameters:
nr_of_timesteps = 10;
nr_of_nodes = 10; ## total number of nodes (including boundary nodes)
delta_z = 10; ## distance between nodes in cm
delta_t = 1; ## distance between time levels in s
H_top = -75; ## boundary condition at the top node in cm
H_bottom = -1000; ## boundary condition at bottom node in cm
H_initial = repelems(-1000,
		 [1;nr_of_nodes])'; ## initial condition at all nodes in cm
## Set parameters for “van_Genuchten_variables” (values taken from Celia et al. (1990), p. 1487 below eq. (13b)):
alpha = 0.0335;
theta_s =0.368;
theta_r = 0.102;
n = 2;
K_s = 0.00922;
[K_initial, theta_initial, C_initial] = van_Genuchten_variables(alpha,
						    n,
						    theta_r,
						    theta_s,
						    K_s,
						    H_initial);
H_n = H_initial;
K_n = K_initial;
theta_n = theta_initial;
C_n = C_initial;

## Template for single iteration:
H_n(1) = H_bottom; ## set H of bottom node to constant value
H_n(nr_of_nodes) = H_top; ## set H of top node to constant value
H_n_plus_1_m = H_n; ## use estimation of last time step as starting value of current iterationn 
[K_n_plus_1_m, theta_n_plus_1_m, C_n_plus_1_m] = van_Genuchten_variables(alpha,
							   n,
							   theta_r,
							   theta_s,
							   K_s,
							   H_n_plus_1_m); ## calculate K, theta, and C using latest estimate of H
K_mean_n_plus_1_m = adjacent_mean(K_n_plus_1_m,
			    "a"); ## calculate K_i_plus_minus_1_over_2

## Create matrix A:
## Note: the matrix elements can only be computed for all nodes excluding the boundary nodes. Therefore, the length of Beta is “nr_of_nodes - 2” and the length of Alpha and Gamma is “nr_of_nodes - 3”.
Alpha = -(K_mean_n_plus_1_m(2:(length(K_mean_n_plus_1_m) -1)) ./ ((delta_z) .^ 2)); ## calculate leftmost diagonal elements of matrix A
Beta = (C_n_plus_1_m(2:(length(C_n_plus_1_m) -1)) ./ delta_t) .+ ((K_mean_n_plus_1_m(1:(length(K_mean_n_plus_1_m) .-1))) ./ (delta_z .^ 2)) + ((K_mean_n_plus_1_m(2:length(K_mean_n_plus_1_m))) ./ (delta_z .^ 2)); ## calculate central diagonal elements of matrix A (excluding the boundary nodes, since Beta cannot be calculated completely for them)
Gamma = Alpha; ## set rightmost diagonal elements of matrix A
A = full(gallery("tridiag",
	       Alpha,
	       Beta,
	       Gamma)); ## create matrix A

H_n_plus_1_m_plus_1 = H_n_plus_1_m .* (1 + (1 / 10 ^ 4)); ## calculate H for next iteration step

delta = H_n_plus_1_m_plus_1(2:(length(H_n_plus_1_m_plus_1)-1)) .- H_n_plus_1_m(2:(length(H_n_plus_1_m)-1)); ## calculate vector delta

f = A \ delta; ## compute residual

fmax = max(f); ## determine maximum value of residual
