## ATTEMPT AT A 1-D VERTICAL MODEL 

## CONVENTIONS:
## - if the water flux `q´ is directed toward the reference level (x = 0), q > 0
## - if the water flux `q´ is directed away from the reference level (x = 0), q < 0
## - x >= 0 for the observed locations
## ==> `K´ (hydraulic conductivity) needs to be positive
## - the equations used for `K(h)´ and `theta(h)´ assume `h´ to be positive and thus use `abs (h)´ for `h´ (see van Genuchten 1980 p. 892, p. 894)
## - `h´ is always <= 0 ?????

## Spatial difference in m
deltaz = -0.01;
## Time difference between time steps in s (s / time step)
deltat = 0.1; ##

## Maximum duration of modelled period in h
DURATION = 0.5 / 1000;
## min / h
MIN_PER_H = 60;
## s / min
SEC_PER_MIN = 60;
## Maximum number of time steps
MAXTIMESTEPS = round((DURATION * MIN_PER_H * SEC_PER_MIN) / abs(deltat));

## Length of domain in m
LENGTH = 1 / 10;
## Maximum number of nodes
MAXNODENUMBER = round(LENGTH / abs(deltaz));

## Parameters for `VanGenuchten(h,VGP)´
alpha = 0.01; ## undetermined parameter (to be estimated, see van Genuchten 1980 p. 894; [alpha] = ?) [0.1 – 0.001]
n = 2; ## undetermined parameter (to be estimated, see van Genuchten 1980 p. 894; [n] = ?) [1.x – 2.5 (normal soil); 10 (sandy soil)]
m = 1 - 1 / n; ## see van Genuchten 1980 p. 893 Eq. [9], p. 894 Eq. [22]; [m] = ? [arbitrary value; necessary for the Mualem model]
theta_S = 0.45; ## water content at saturation (see van Genuchten 1980 p. 892 below Eq. [2]; dimensionless)
theta_R = 0.05; ## residual water content (see van Genuchten 1980 p. 892 below Eq. [2]; dimensionless)
VGP = [alpha,
       n,
       m,
       theta_S,
       theta_R];

## Function `VanGenuchten(h, VGP)´ for calculating `theta´, `K´, and `C´
function [theta, K, C] = VanGenuchten(h,VGP)
  ## FUNCTION VARIABLES
  alpha = VGP(1);
  n = VGP(2);
  m = VGP(3);
  theta_S = VGP(4);
  theta_R = VGP(5);
  ## FUNCTION BODY
  ## Function to calculate `K(h)´ (see van Genuchten 1980 p. 893 Eq. [9]; [K(h)] = m/s ?]
  #K = (1 - (alpha .* h) .^ (n - 1) .* (1+(alpha .* h) .^ n) .^  - m) .^ 2 ./ (1+(alpha .* h) .^ n) .^ (m ./ 2); # form requiring `h´ to be positive
  K = (1 - (alpha .* abs (h)) .^ (n - 1) .* (1+(alpha .* abs (h)) .^ n) .^  - m) .^ 2 ./ (1+(alpha .* abs (h)) .^ n) .^ (m ./ 2); # form using `abs (h)´ for `h´
  ## Function to caclulate `C(h)´ (see Mohsen’s code; result of deriving (del theta/del h); [C(h) = 1 / m ?])
  C = (alpha .* m .* n .* sign(h) .* (alpha .* abs (h)) .^ (n - 1) .* (theta_R - theta_S)) ./ ((alpha .* abs (h)) .^ n + 1) .^ (m + 1); # form using `abs (h)´ for `h´
  ## Function to calculate `theta(h)´ (see van Genuchten 1980 p. 894 Eq. [21]; dimensionless)
  theta = theta_R + ((theta_S - theta_R) ./ (1 + (alpha .* abs (h)).^n).^m); # form using `abs (h)´ for `h´
endfunction

## Function `hfunc(theta, VGP)´ for calculating `h´ (resolution of function `theta(h)´ (see above))
function [h] = hfunc(theta, VGP)
  alpha = VGP(1);
  n = VGP(2);
  m = VGP(3);
  theta_S = VGP(4);
  h = nthroot (nthroot (theta_S ./ theta, m) - 1, n) ./ alpha; ## WRONG; not sure whether `theta(h)´ can be solved for `h´
endfunction

## Function `Sink(h)´ for calculating the sink term (see Hydrus manual eq. (2.7); the function assumes `h´ to be negative)
function [rwusr, S] = Sink(h, VGP)
  ## FUNCTION PARAMETERS
  Sp = 0.01; ## potential water uptake rate
  hsat = hfunc(VGP(4), VGP);
  hwilt = hfunc(VGP(5), VGP);
  h2 = (hwilt - hsat) .* 0.1; ## arbitrarily set
  h3 = (hwilt - hsat) .* 0.75; ## arbitrarily set
  ## FUNCTION BODY
  if (and (hwilt <= h, h < h3))
    m = (0 - 1) ./ (hwilt - h3);
    b = hwilt ./ (hwilt - h3);
    rwusr = m .* h + b;
  elseif (and (h3 <= h, h <= h2))
    rwusr = 1;
  elseif (and (h2 < h, h <= hsat))
    m = -1 .* abs (1 ./ (h2 - hsat));
    b = hsat ./ (h2 - hsat);
    rwusr = m .* h + b;
  endif
  S =  rwusr .* Sp;
endfunction

## Create empty matrix `thetamat´ to contain the calculations of `theta´ given by `VanGenuchten(h,VGP)´ for every node and time step
thetamat = zeros(MAXNODENUMBER, MAXTIMESTEPS);

## Create empty matrix `Hmat´ to contain the estimations of `h´ for every node and time step
Hmat = zeros(MAXNODENUMBER, MAXTIMESTEPS);

## ## Set the initial estimation of `h´ for the first node and calculate the estimations of `h´ for the other nodes based on the estimation for the first node
H_init_value_first = -20;
H_init_value_other = H_init_value_first ./ 2;
H_init_vector = ones(1, MAXNODENUMBER) .* H_init_value_other;
H_init_vector(1) = H_init_value_first;
Hmat(:,1) = H_init_vector;

## Calculate the initial values of `theta(h)´ and `K(h)´ given by `VanGenuchten(h,VGP)´ using the initial estimations of `h´ for all nodes
[theta_init, K_init] = VanGenuchten(H_init_vector,VGP);
thetamat(:, 1) = theta_init;

## Set the threshold for `deltah´
threshold = 1;

## ## Set maximum number of model runs
## MAXRUNS = 5;

## ## Create arrays to contain `thetamat´ and `Hmat´ of the different runs
## thetaarray = {};
## Harray = {};

## for RUN = 1:MAXRUNS
  
##   ## Set the initial estimation of `h´ for node 1 and calculate the estimations of `h´ for the other nodes based on the estimation for node 1 differently for each run
##   H_init_value_first = -20 * RUN;
##   H_init_value_other = H_init_value_first ./ 2;
##   H_init_vector = ones(1, MAXNODENUMBER) .* H_init_value_other;
##   H_init_vector(1) = H_init_value_first;
##   Hmat(:,1) = H_init_vector;

for TIMESTEP = 2:MAXTIMESTEPS
  
  Hn = Hmat(:, TIMESTEP-1);
  HnPlus1m = Hn;

  stop = 0;
  
  while (stop == 0)
    [thetanPlus1m, KnPlus1m, CnPlus1m] = VanGenuchten(HnPlus1m,VGP);
    
    Kplus = 2 .* (KnPlus1m(2:end) .^ -1 + KnPlus1m(1:end - 1) .^ -1) .^ -1;
    Kplus = [Kplus; Kplus(end)];

    Kminus = 2 .* (KnPlus1m(1:end -1 ) .^ -1 + KnPlus1m(2:end) .^ -1) .^ -1;
    Kminus = [Kminus(1); Kminus];

    a = - (Kminus ./ (deltaz) ^ 2);
    b = (CnPlus1m ./ deltat) + (Kplus ./ (deltaz) ^ 2) + (Kminus ./ (deltaz) ^ 2);
    c = - (Kplus ./ (deltaz) ^ 2);

    A = sparse(diag(b) + diag(a(2:end), -1) + diag(c(1:end -1), +1));

    Hplus = HnPlus1m(2:end) - HnPlus1m(1:end - 1);
    Hplus = [Hplus; 0];

    Hminus = HnPlus1m(2:end) - HnPlus1m(1:end - 1);
    Hminus = [0; Hminus];

    Sink = Sink(HnPlus1m, VGP);
    
    f = (1 / (deltaz) ^ 2) .* (Kplus .* Hplus - Kminus .* Hminus) + (Kplus - Kminus) ./ deltaz  - CnPlus1m .* ((HnPlus1m - Hn) ./ deltat); 

    ## Boundary condition for first node: constant pressure
    a(1)=0;
    a(2)=0;
    b(1)=1;
    c(1)=0;
    f(1)=0;

    ## Boundary condition for last node: no flux to/from following node

    a(MAXNODENUMBER) = - (Kminus(MAXNODENUMBER) ./ (deltaz) ^ 2);
    b(MAXNODENUMBER) = (CnPlus1m(MAXNODENUMBER) ./ deltat) + 0 + (Kminus(MAXNODENUMBER) ./ (deltaz) ^ 2);
    c(MAXNODENUMBER) = 0;
    f(MAXNODENUMBER) = (1 / (deltaz) ^ 2) .* (0 - Kminus(MAXNODENUMBER) .* Hminus(MAXNODENUMBER)) + (0 - Kminus(MAXNODENUMBER)) ./ deltaz  - CnPlus1m(MAXNODENUMBER) .* ((HnPlus1m(MAXNODENUMBER) - Hn(MAXNODENUMBER)) ./ deltat);

    deltah = A \ sparse(f);

    if (deltah < threshold)

      HnPlus1mPlus1 = HnPlus1m + deltah;
      HnPlus1mPlus1(1) = H_init_value_first;
      [thetanPlus1mPlus1] = VanGenuchten(HnPlus1mPlus1,VGP);
      stop = 1;
      
    else

      HnPlus1m = HnPlus1m + deltah;
      HnPlus1m(1) = H_init_value_first;
      stop = 0;

    endif

  endwhile

  Hmat(:, TIMESTEP) = HnPlus1mPlus1;
  thetamat(:, TIMESTEP) = thetanPlus1mPlus1;

  Sink
  
endfor

##   if (RUN < 10)    
##     RUNSTRING = [num2str(0) num2str(RUN)];
##   else
##     RUNSTRING = num2str(RUN);
##   endif
  
##   FILENAME = ["~/DATEN02_3.Sem/Projekt/Daten/Probelaeufe/thetamat" RUNSTRING ".txt"];
##   save ("-ascii", FILENAME, "thetamat")
##   FILENAME = ["~/DATEN02_3.Sem/Projekt/Daten/Probelaeufe/Hmat" RUNSTRING ".txt"];
##   save ("-ascii", FILENAME, "Hmat")
  
## endfor

## ## Testing
## htest = 0.35 .* (hwilt - h3) + h3;
## [result] = Sink(htest, VGP);
## result
## htest = h3;
## [result] = Sink(htest, VGP);
## result
## htest = h2;
## [result] = Sink(htest, VGP);
## result
## htest = hsat;
## [result] = Sink(htest, VGP);
## result
